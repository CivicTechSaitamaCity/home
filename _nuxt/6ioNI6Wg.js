import{m as N,L as T,I as V,M as h,N as M,O as S,P as j,j as F,Q as H,R as L,s as C,J as U,S as z,u as I,T as J}from"./Ba-e5sjW.js";const Q={trailing:!0};function q(e,t=25,i={}){if(i={...Q,...i},!Number.isFinite(t))throw new TypeError("Expected `wait` to be a finite number");let n,a,s=[],r,m;const c=(_,u)=>(r=G(e,_,u),r.finally(()=>{if(r=null,i.trailing&&m&&!a){const v=c(_,m);return m=null,v}}),r);return function(..._){return r?(i.trailing&&(m=_),r):new Promise(u=>{const v=!a&&i.leading;clearTimeout(a),a=setTimeout(()=>{a=null;const o=i.leading?n:c(this,_);for(const D of s)D(o);s=[]},t),v?(n=c(this,_),u(n)):s.push(u)})}}async function G(e,t,i){return await e.apply(t,i)}const W=e=>e==="defer"||e===!1;function Z(...e){var w;const t=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&typeof e[0]!="object"&&!(typeof e[0]=="function"&&typeof e[1]=="function")&&e.unshift(t);let[i,n,a={}]=e;const s=N(()=>T(i));if(typeof s.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof n!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const r=V(),m=()=>h.value,c=(y,f,P)=>{if(f.isHydrating)return f.payload.data[y];if(P.cause!=="refresh:manual"&&P.cause!=="refresh:hook")return f.static.data[y]};a.server??(a.server=!0),a.default??(a.default=m),a.getCachedData??(a.getCachedData=c),a.lazy??(a.lazy=!1),a.immediate??(a.immediate=!0),a.deep??(a.deep=h.deep),a.dedupe??(a.dedupe="cancel"),a._functionName,r._asyncData[s.value];const _=a.getCachedData(s.value,r,{cause:"initial"});(w=r._asyncData[s.value])!=null&&w._deps||(r._asyncData[s.value]=B(r,s.value,n,a,_));const u=r._asyncData[s.value];u._deps++;const v=()=>r._asyncData[s.value].execute({cause:"initial",dedupe:a.dedupe}),o=a.server!==!1&&r.payload.serverRendered;{let y=function(l){const d=r._asyncData[l];d!=null&&d._deps&&(d._deps--,d._deps===0&&(d==null||d._off(),O(r,l),d.execute=()=>Promise.resolve(),r._asyncData[l].data.value=h.value))};const f=M();if(f&&o&&a.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const l=f._nuxtOnBeforeMountCbs;S(()=>{l.forEach(d=>{d()}),l.splice(0,l.length)}),j(()=>l.splice(0,l.length))}o&&r.isHydrating&&(u.error.value||_!=null)?(u.pending.value=!1,u.status.value=u.error.value?"error":"success"):f&&(r.payload.serverRendered&&r.isHydrating||a.lazy)&&a.immediate?f._nuxtOnBeforeMountCbs.push(v):a.immediate&&v();const P=J(),R=F([s,...a.watch||[]],([l],[d])=>{var E;if(d===l){u._execute({cause:"watch",dedupe:a.dedupe});return}d&&y(d),(E=r._asyncData[l])!=null&&E._deps||(r._asyncData[l]=B(r,l,n,a,a.getCachedData(l,r,{cause:"initial"}))),r._asyncData[l]._deps++,a.immediate&&r._asyncData[l].execute({cause:"initial",dedupe:a.dedupe})});P&&H(()=>{R(),y(s.value)})}const D={data:b(()=>r._asyncData[s.value].data),pending:b(()=>r._asyncData[s.value].pending),status:b(()=>r._asyncData[s.value].status),error:b(()=>r._asyncData[s.value].error),refresh:(...y)=>r._asyncData[s.value].execute(...y),execute:(...y)=>r._asyncData[s.value].execute(...y),clear:()=>O(r,s.value)},g=Promise.resolve(r._asyncDataPromises[s.value]).then(()=>D);return Object.assign(g,D),g}function b(e){return N({get(){return e().value},set(t){e().value=t}})}function O(e,t){t in e.payload.data&&(e.payload.data[t]=void 0),t in e.payload._errors&&(e.payload._errors[t]=h.errorValue),e._asyncData[t]&&(e._asyncData[t].data.value=void 0,e._asyncData[t].error.value=h.errorValue,e._asyncData[t].pending.value=!1,e._asyncData[t].status.value="idle"),t in e._asyncDataPromises&&(e._asyncDataPromises[t]&&(e._asyncDataPromises[t].cancelled=!0),e._asyncDataPromises[t]=void 0)}function X(e,t){const i={};for(const n of t)i[n]=e[n];return i}function B(e,t,i,n,a){var _;(_=e.payload._errors)[t]??(_[t]=h.errorValue);const s=i,r=n.deep?L:C,m=a!=null,c={data:r(m?a:n.default()),pending:C(!m),error:U(e.payload._errors,t),status:C("idle"),execute:(u={})=>{if(e._asyncDataPromises[t]){if(W(u.dedupe??n.dedupe))return e._asyncDataPromises[t];e._asyncDataPromises[t].cancelled=!0}if(u.cause==="initial"||e.isHydrating){const o=u.cause==="initial"?a:n.getCachedData(t,e,{cause:u.cause??"refresh:manual"});if(o!=null)return e.payload.data[t]=c.data.value=o,c.error.value=h.errorValue,c.status.value="success",Promise.resolve(o)}c.pending.value=!0,c.status.value="pending";const v=new Promise((o,D)=>{try{o(s(e))}catch(g){D(g)}}).then(async o=>{if(v.cancelled)return e._asyncDataPromises[t];let D=o;n.transform&&(D=await n.transform(o)),n.pick&&(D=X(D,n.pick)),e.payload.data[t]=D,c.data.value=D,c.error.value=h.errorValue,c.status.value="success"}).catch(o=>{if(v.cancelled)return e._asyncDataPromises[t];c.error.value=z(o),c.data.value=I(n.default()),c.status.value="error"}).finally(()=>{v.cancelled||(c.pending.value=!1,delete e._asyncDataPromises[t])});return e._asyncDataPromises[t]=v,e._asyncDataPromises[t]},_execute:q((...u)=>c.execute(...u),0,{leading:!0}),_default:n.default,_deps:0,_hash:void 0,_off:e.hook("app:data:refresh",async u=>{(!u||u.includes(t))&&await c.execute({cause:"refresh:hook"})})};return c}export{Z as u};
